<!DOCTYPE html>
<html>
<head>
<title>Flappy Ball - Nguyen Bac Son</title>
<style>
/* --- CSS --- */
.footer {
    background-color: #f8f9fa;
    padding: 15px 20px;
    border-top: 1px solid #e9ecef;
    text-align: center;
    font-size: 14px;
    color: #6c757d;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    width: 100%;
}

.footer a {
    color: #007bff;
    text-decoration: none;
    margin: 0 10px;
}

.footer a:hover {
    text-decoration: underline;
}

body {
    margin-bottom: 70px;
}
    body {
        margin: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        /* M√†u n·ªÅn t·ªïng th·ªÉ cho m√†n h√¨nh Start (s·ª≠ d·ª•ng m√†u t·ªëi h∆°n cho kh√¥ng gian) */
        background-color: #12121e; 
        font-family: Arial, sans-serif;
        color: white;
    }
    #gameCanvas {
        display: none;
        border: 2px solid #000;
        touch-action: manipulation;
    }
    #startScreen {
        text-align: center;
        padding: 20px;
        background-color: rgba(0, 0, 0, 0.7); /* T·ªëi h∆°n */
        border-radius: 10px;
        width: 90%;
        max-width: 400px;
    }
    input, button, select { 
        padding: 15px;
        margin: 10px 0;
        font-size: 20px;
        border-radius: 8px;
        border: none;
        box-sizing: border-box;
        width: 100%;
        color: #333;
    }
    #startButton {
        background-color: #4CAF50;
        color: white;
        cursor: pointer;
        width: 100%;
    }
    #leaderboard h3 {
        margin-top: 20px;
        color: #ffeb3b;
        font-size: 24px;
    }
    #leaderboard ol {
        list-style-type: none;
        padding: 0;
        text-align: left;
    }
    #leaderboard li {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        font-size: 18px;
        transition: background-color 0.3s;
    }
    .current-player {
        background-color: rgba(255, 255, 255, 0.2);
        border-radius: 5px;
    }
    /* Th·ªëng k√™ Game Over */
    #gameOverStats {
        background-color: rgba(255, 255, 255, 0.1);
        padding: 10px 15px;
        border-radius: 8px;
        margin-top: 15px;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    #gameOverStats p {
        margin: 5px 0;
        font-size: 18px;
        font-weight: bold;
    }
</style>
</head>
<body>

<audio id="bgm" src="assets/bgm.mp3" loop></audio>

<div id="startScreen">
    <h1>Flappy Ball - Nguyen Bac Son‚öΩ</h1>
    
    <div id="leaderboard">
        <h3>üèÜ Ranking üèÜ</h3>
        <ol id="leaderboardList"></ol>
    </div>

    <select id="difficultySelect">
        <option value="easy">Easy (Slow Speed, Wide Distance)</option>
        <option value="normal" selected>Normal (Default)</option>
        <option value="hard">Difficult (Fast Speed, Narrow Space)</option>
        <option value="extreme">Extremely Hard (Super Fast, Super Narrow)</option>
    </select>
    
    <input type="text" id="nameInput" placeholder="Your name" maxlength="15">
    <button id="startButton" disabled>Start</button>
    
    <div id="gameOverStats" style="display: none;">
        <h4 style="margin: 5px 0; color: #ffeb3b;">MATCH STATISTICS</h4>
        <p id="finalScore"></p>
        <p id="highScore"></p>
        <p id="difficultyPlayed"></p>
    </div>
</div>

<canvas id="gameCanvas" width="800" height="1200"></canvas>

<div class="footer">
    B·∫£n quy·ªÅn ¬© 2025 thu·ªôc v·ªÅ Nguyen Bac Son. | 
    <a href="https://nguyenbacson.io.vn/privacy-policy.html">Ch√≠nh s√°ch b·∫£o m·∫≠t</a>
</div>

<script>
    // --- PH·∫¶N 1: KHAI B√ÅO & C·∫§U H√åNH ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('startScreen');
    const nameInput = document.getElementById('nameInput');
    const startButton = document.getElementById('startButton');
    const leaderboardList = document.getElementById('leaderboardList');
    const difficultySelect = document.getElementById('difficultySelect');
    
    // UI Elements
    const gameOverStats = document.getElementById('gameOverStats');
    const finalScoreDisplay = document.getElementById('finalScore');
    const highScoreDisplay = document.getElementById('highScore');
    const difficultyPlayedDisplay = document.getElementById('difficultyPlayed');
    
    // Audio
    const bgm = document.getElementById('bgm');
    const soundFlap = new Audio('assets/flap.wav');
    const soundScore = new Audio('assets/score.wav');
    const soundHit = new Audio('assets/hit.wav');

    bgm.volume = 0.5;
    soundFlap.volume = 0.8;
    soundScore.volume = 0.7;
    soundHit.volume = 1.0;
    
    // Game Physics & Constants
    const BALL_RADIUS = 30;
    const BALL_SIZE = BALL_RADIUS * 2;
    const SEAWEED_WIDTH = 120;
    const GRAVITY = 1.2;
    const DRAG = 0.96;
    const FLAP_FORCE = -20;
    const GROUND_HEIGHT = 100;
    const BALL_X = 100;
    
    // Optimized Constants
    const CANVAS_WIDTH = canvas.width;
    const CANVAS_HEIGHT = canvas.height;

    // Difficulty Settings
    const DIFFICULTY_SETTINGS = {
        easy: { speed: 4.0, gap: 320, interval: 2200, name: "D·ªÖ" }, 
        normal: { speed: 5.0, gap: 280, interval: 2000, name: "Th∆∞·ªùng" }, 
        hard: { speed: 6.5, gap: 250, interval: 1800, name: "Kh√≥" }, 
        extreme: { speed: 8.0, gap: 220, interval: 1600, name: "C·ª±c Kh√≥" } 
    };
    
    let currentSpeed = DIFFICULTY_SETTINGS.normal.speed;
    let currentGap = DIFFICULTY_SETTINGS.normal.gap;
    let currentInterval = DIFFICULTY_SETTINGS.normal.interval;
    let currentDifficulty = 'normal';

    // Parallax Color Setup
    let backgroundScrollOffset = 0; 
    const PARALLAX_SLOW = 0.5; 
    const PARALLAX_FAST = 0.8; 
    
    // Game State
    let playerName = '';
    let ballY, ballVelocity;
    let seaweed = [];
    let bubbles = [];
    let particles = []; 
    let score;
    let isGameOver;
    let isGameRunning = false;
    let pipeInterval;
    const LEADERBOARD_KEY = 'flappyBallLeaderboard';
    const HIGHSCORE_KEY = 'flappyBallHighScores';

    // Sample Data
    const SAMPLE_LEADERBOARD = [
        { name: 'Nguyen Bac Son', score: 427, timestamp: Date.now() - 50000000 },
    ];

    // Asset Loading MATCH STATISTICS
    const assets = {};
    let assetsLoaded = 0;
    const totalAssets = 2; 

    function loadImage(name, src) {
        const img = new Image();
        img.src = src;
        img.onload = () => {
            assets[name] = img;
            assetsLoaded++;
            checkAssetsLoaded();
        };
        img.onerror = () => {
            console.warn(`Failed to load image: ${src}. Using fallback color.`);
            assetsLoaded++;
            checkAssetsLoaded();
        };
    }
    
    loadImage('seaweed_top', 'assets/seaweed_top.png'); 
    loadImage('seaweed_bottom', 'assets/seaweed_bottom.png'); 

    function checkAssetsLoaded() {
         if (assetsLoaded === totalAssets && nameInput.value.trim().length > 0) {
             startButton.disabled = false;
         }
    }
    
    // Drawing Functions
    function drawSeaweed(x, height) {
        const topImg = assets.seaweed_top;
        const bottomImg = assets.seaweed_bottom;

        if (topImg && bottomImg) {
            ctx.drawImage(topImg, x, height - topImg.height, SEAWEED_WIDTH, topImg.height);
            ctx.drawImage(bottomImg, x, height + currentGap, SEAWEED_WIDTH, CANVAS_HEIGHT - GROUND_HEIGHT - (height + currentGap));
        } else {
            // Fallback: Use solid color
            ctx.fillStyle = '#4CAF50'; 
            ctx.fillRect(x, 0, SEAWEED_WIDTH, height);
            ctx.fillRect(x, height + currentGap, SEAWEED_WIDTH, CANVAS_HEIGHT - GROUND_HEIGHT - (height + currentGap));
        }
    }

    function drawBall() {
        const ballImg = assets.ball; 

        ctx.save();
        ctx.translate(BALL_X + BALL_RADIUS, ballY + BALL_RADIUS);

        if (ballImg) {
             ctx.drawImage(ballImg, -BALL_RADIUS, -BALL_RADIUS, BALL_SIZE, BALL_SIZE);
        } else {
             // Fallback: Draw circle
             ctx.beginPath();
             ctx.arc(0, 0, BALL_RADIUS, 0, Math.PI * 2);
             ctx.fillStyle = '#ffcc00'; 
             ctx.fill();
             ctx.lineWidth = 3;
             ctx.strokeStyle = '#333';
             ctx.stroke();
             ctx.closePath();
        }
        ctx.restore();
    }
    
    // Parallax Gradient Initialization
    let backgroundGradientSlow;
    let backgroundGradientFast;
    
    function createGradients() {
        backgroundGradientSlow = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        backgroundGradientSlow.addColorStop(0, '#10002b'); 
        backgroundGradientSlow.addColorStop(1, '#000033'); 
        
        backgroundGradientFast = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        backgroundGradientFast.addColorStop(0, 'rgba(30, 0, 80, 0.5)'); 
        backgroundGradientFast.addColorStop(1, 'rgba(0, 50, 100, 0.5)'); 
    }
    createGradients(); 

    function drawParallaxBackground() {
        if (isGameRunning && !isGameOver) {
            backgroundScrollOffset = (backgroundScrollOffset - currentSpeed) % CANVAS_WIDTH;
        }

        // 1. Static dark background
        ctx.fillStyle = '#12121e';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // 2. Slow layer
        ctx.fillStyle = backgroundGradientSlow;
        ctx.save();
        ctx.translate(backgroundScrollOffset * PARALLAX_SLOW, 0); 
        ctx.fillRect(-CANVAS_WIDTH, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT); 
        ctx.restore();
        
        // 3. Fast layer
        ctx.fillStyle = backgroundGradientFast;
        ctx.save();
        ctx.translate(backgroundScrollOffset * PARALLAX_FAST, 0); 
        ctx.fillRect(-CANVAS_WIDTH, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT); 
        ctx.restore();
    }
    
    // Bubble Class (Hi·ªáu ·ª©ng bong b√≥ng khi bay l√™n)
    class Bubble {
        constructor(x, y) {
            this.x = x + Math.random() * 10 - 5;
            this.y = y;
            this.radius = Math.random() * 5 + 1;
            this.life = 60;
            this.vx = (Math.random() - 0.5) * 1.5;
            this.vy = Math.random() * -2 - 1;
            this.alpha = 1;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            this.alpha = this.life / 60;
        }

        draw() {
            ctx.globalAlpha = this.alpha;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
            ctx.closePath();
            ctx.globalAlpha = 1.0;
        }
    }

    // Particle Class (Hi·ªáu ·ª©ng tia l·ª≠a khi g·∫ßn ƒë·∫•t)
    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 5 + 1;
            this.life = 30; // 0.5 gi√¢y
            this.vx = (Math.random() * 6) - 3;
            this.vy = Math.random() * -5 - 2;
            this.gravity = 0.3;
            this.color = `hsl(${Math.random() * 60 + 20}, 100%, 50%)`; // V√†ng cam
        }

        update() {
            this.x += this.vx;
            this.vy += this.gravity;
            this.y += this.vy;
            this.life--;
        }

        draw() {
            ctx.globalAlpha = this.life / 30;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }
    
    // Data/Leaderboard Functions 
    function getHighScores() {
        const data = localStorage.getItem(HIGHSCORE_KEY);
        return data ? JSON.parse(data) : {};
    }

    function updateHighScores(difficulty, newScore) {
        const highScores = getHighScores();
        if (!highScores[difficulty] || newScore > highScores[difficulty]) {
            highScores[difficulty] = newScore;
            localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(highScores));
            return true; 
        }
        return false;
    }

    function getCombinedLeaderboard() {
        const localData = localStorage.getItem(LEADERBOARD_KEY);
        const localLeaderboard = localData ? JSON.parse(localData) : [];
        let combined = [...SAMPLE_LEADERBOARD, ...localLeaderboard];
        
        combined.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return a.timestamp - b.timestamp; 
        });
        
        const uniquePlayers = {};
        combined.forEach(p => {
            if (!uniquePlayers[p.name] || p.score > uniquePlayers[p.name].score) {
                 uniquePlayers[p.name] = p;
            }
        });

        return Object.values(uniquePlayers).sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return a.timestamp - b.timestamp; 
        }).slice(0, 10);
    }

    function saveScore(name, finalScore) {
        const localLeaderboard = localStorage.getItem(LEADERBOARD_KEY);
        const data = localLeaderboard ? JSON.parse(localLeaderboard) : [];
        const fullName = `${name} [${currentDifficulty.toUpperCase()}]`; 
        const existingIndex = data.findIndex(p => p.name === fullName);

        if (existingIndex !== -1) {
            if (finalScore > data[existingIndex].score) {
                data[existingIndex].score = finalScore;
                data[existingIndex].timestamp = Date.now();
            }
        } else {
            data.push({ name: fullName, score: finalScore, timestamp: Date.now() });
        }
        localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(data));
        updateHighScores(currentDifficulty, finalScore);
        renderLeaderboard();
    }

    function renderLeaderboard() {
        const top10 = getCombinedLeaderboard();
        leaderboardList.innerHTML = ''; 

        if (top10.length === 0) {
            leaderboardList.innerHTML = '<li>Ch∆°i ƒë·ªÉ l·∫≠p k·ª∑ l·ª•c!</li>';
            return;
        }

        top10.forEach((player, index) => {
            const isCurrentPlayer = player.name.includes(playerName) && playerName.length > 0 && !player.name.startsWith('Server:'); 
            const li = document.createElement('li');
            
            if (isCurrentPlayer) {
                li.classList.add('current-player');
            }

            li.innerHTML = `
                <span>${index + 1}.</span>
                <span>${player.name}</span>
                <span style="font-weight: bold;">${player.score}</span>
            `;
            leaderboardList.appendChild(li);
        });
    }

    function setDifficulty(level) {
        const settings = DIFFICULTY_SETTINGS[level];
        currentSpeed = settings.speed;
        currentGap = settings.gap;
        currentInterval = settings.interval;
        currentDifficulty = level;
    }

    function showGameOverStats(finalScore) {
        const highScores = getHighScores();
        const currentHighScore = highScores[currentDifficulty] || 0;
        const difficultyName = DIFFICULTY_SETTINGS[currentDifficulty].name;
        
        finalScoreDisplay.innerHTML = `ƒêi·ªÉm c·ªßa b·∫°n: <span style="color: #4CAF50;">${finalScore}</span>`;
        highScoreDisplay.innerHTML = `K·ª∑ l·ª•c (${difficultyName}): <span style="color: #ffeb3b;">${currentHighScore}</span>`;
        difficultyPlayedDisplay.innerHTML = `C·∫•p ƒë·ªô: <span style="text-transform: uppercase;">${difficultyName}</span>`;
        
        gameOverStats.style.display = 'block';
    }

    function hideGameOverStats() {
        gameOverStats.style.display = 'none';
    }
// ƒê√ìNG PH·∫¶N 1
    // --- PH·∫¶N 2: LOGIC GAME V√Ä V√íNG L·∫∂P CH√çNH ---
    function flap() { 
        if (!isGameOver) {
            ballVelocity = FLAP_FORCE; 
            soundFlap.currentTime = 0;
            soundFlap.play();
        }
    } 

    function gameOver() {
        isGameOver = true;
        isGameRunning = false;
        clearInterval(pipeInterval);
        bgm.pause(); 
        
        saveScore(playerName, score);
        showGameOverStats(score); 
    }
    
    function restartGame() {
        ballY = CANVAS_HEIGHT / 2;
        ballVelocity = 0;
        seaweed = [];
        bubbles = [];
        particles = []; 
        score = 0;
        isGameOver = false;
        isGameRunning = false;
        backgroundScrollOffset = 0; 
        if (pipeInterval) clearInterval(pipeInterval);
        
        hideGameOverStats(); 
    }
    
    function updateBall() {
        ballVelocity *= DRAG; 
        ballVelocity += GRAVITY;

        // T·∫°o bong b√≥ng khi bay l√™n (Flap)
        if (ballVelocity < -5) {
             for (let i = 0; i < 2; i++) {
                 bubbles.push(new Bubble(BALL_X + BALL_RADIUS, ballY + BALL_RADIUS));
             }
        }
        
        ballY += ballVelocity;
        
        // LOGIC T·∫†O TIA L·ª¨A KHI G·∫¶N CH·∫†M ƒê·∫§T
        const groundThreshold = CANVAS_HEIGHT - GROUND_HEIGHT - BALL_SIZE;
        const proximity = groundThreshold - ballY;
        
        if (proximity < 50 && ballVelocity > 0) { 
            const intensity = 1 - (proximity / 50); 
            const particleCount = Math.floor(intensity * 4); 
            
            for(let i = 0; i < particleCount; i++) {
                particles.push(new Particle(
                    BALL_X + BALL_RADIUS + (Math.random() * 10 - 5), 
                    ballY + BALL_SIZE - 5
                ));
            }
        }

        // Ki·ªÉm tra va ch·∫°m ƒë·∫•t
        if (ballY + BALL_SIZE > CANVAS_HEIGHT - GROUND_HEIGHT) {
            gameOver();
            soundHit.play();
        }
        if (ballY < 0) ballY = 0;
    }

    function updateSeaweeds() {
        let i = seaweed.length;
        while (i--) {
            const item = seaweed[i];
            item.x -= currentSpeed;

            // 1. Ki·ªÉm tra ghi ƒëi·ªÉm
            if (item.x + SEAWEED_WIDTH < BALL_X && !item.passed) {
                score++;
                item.passed = true;
                soundScore.play();
            }

            // 2. Ki·ªÉm tra va ch·∫°m
            if (
                BALL_X + BALL_SIZE > item.x && 
                BALL_X < item.x + SEAWEED_WIDTH && 
                (ballY < item.height || ballY + BALL_SIZE > item.height + currentGap)
            ) {
                gameOver();
                soundHit.play();
                return; 
            }

            // 3. Lo·∫°i b·ªè v·∫≠t c·∫£n
            if (item.x + SEAWEED_WIDTH < 0) {
                seaweed.splice(i, 1);
            }
        }
    }

    function generateSeaweed() {
        const minHeight = 100;
        const maxHeight = CANVAS_HEIGHT - GROUND_HEIGHT - currentGap - minHeight; 
        const randomHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
        seaweed.push({ x: CANVAS_WIDTH, height: randomHeight, passed: false });
    }
    
    // --- V√íNG L·∫∂P CH√çNH ---
    function gameLoop() {
        
        // 1. V·∫º N·ªÄN V≈® TR·ª§ (Parallax Color Gradient)
        drawParallaxBackground();

        if (isGameRunning && !isGameOver) {
            updateBall();
            updateSeaweeds();
        }
        
        // 2. V·∫Ω v·∫≠t c·∫£n
        seaweed.forEach(item => drawSeaweed(item.x, item.height)); 
        
        // 3. V·∫º ƒê·∫§T
        ctx.fillStyle = '#ccaa66'; 
        ctx.fillRect(0, CANVAS_HEIGHT - GROUND_HEIGHT, CANVAS_WIDTH, GROUND_HEIGHT); 
        
        // 4. V·∫Ω b√≥ng v√† hi·ªáu ·ª©ng
        drawBall(); 
        
        // C·∫≠p nh·∫≠t v√† v·∫Ω b·ªçt n∆∞·ªõc
        for (let i = 0; i < bubbles.length; i++) {
             bubbles[i].update();
             bubbles[i].draw();
        }
        bubbles = bubbles.filter(bubble => bubble.life > 0); 
        
        // C·∫≠p nh·∫≠t v√† v·∫Ω tia l·ª≠a
        for (let i = 0; i < particles.length; i++) {
             particles[i].update();
             particles[i].draw();
        }
        particles = particles.filter(particle => particle.life > 0); 

        // 5. V·∫Ω ƒëi·ªÉm s·ªë v√† UI
        ctx.fillStyle = 'white';
        ctx.font = '50px Arial';
        ctx.fillText(`Score: ${score}`, 20, 60);
        
        ctx.font = '36px Arial';
        const displayPlayerName = isGameRunning ? `${playerName} [${DIFFICULTY_SETTINGS[currentDifficulty].name}]` : playerName;
        ctx.fillText(`Player: ${displayPlayerName}`, 20, 110);

        if (!isGameOver && !isGameRunning) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = '60px Arial';
            ctx.fillText('Ch·∫°m ƒë·ªÉ B·∫ÆT ƒê·∫¶U CH∆†I', CANVAS_WIDTH / 2 - 350, CANVAS_HEIGHT / 2);
        }
        
        if (isGameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = 'white';
            ctx.font = '70px Arial';
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2 - 200, CANVAS_HEIGHT / 2 - 50);
            ctx.font = '36px Arial';
            ctx.fillText('Ch·∫°m/Click ƒë·ªÉ tr·ªü l·∫°i Menu', CANVAS_WIDTH / 2 - 250, CANVAS_HEIGHT / 2 + 30);
        }

        requestAnimationFrame(gameLoop);
    }
    
    // --- X·ª¨ L√ù ƒê·∫¶U V√ÄO & S·ª∞ KI·ªÜN ---
    function handleInput() {
        if (!playerName) return;
        
        if (isGameOver) {
            // Logic tr·ªü v·ªÅ Menu
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            restartGame();
            renderLeaderboard();
        } else if (!isGameRunning) {
            // Logic B·∫ÆT ƒê·∫¶U CH∆†I (Bao g·ªìm c√∫ FLAP ƒë·∫ßu ti√™n)
            restartGame();
            isGameRunning = true;
            bgm.currentTime = 0;
            bgm.play().catch(e => console.log('BGM Autoplay blocked:', e)); 
            pipeInterval = setInterval(generateSeaweed, currentInterval);
            
            // Th·ª±c hi·ªán c√∫ FLAP ƒë·∫ßu ti√™n
            flap(); 
        } else {
            // Logic FLAP (Nh·∫£y) khi ƒëang ch∆°i
            flap();
        }
    }

    // Event Listeners
    canvas.addEventListener('mousedown', handleInput);
    canvas.addEventListener('touchstart', handleInput);

    // THAY ƒê·ªîI: Ch·ªâ chuy·ªÉn m√†n h√¨nh, kh√¥ng g·ªçi handleInput() ƒë·ªÉ game ch∆∞a ch·∫°y ngay
    startButton.addEventListener('click', () => {
        playerName = nameInput.value.trim(); // L·∫•y t√™n
        if (!playerName) return;

        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('gameCanvas').style.display = 'block';
        // L·∫ßn click/ch·∫°m ti·∫øp theo tr√™n Canvas s·∫Ω kh·ªüi ƒë·ªông game.
    });

    difficultySelect.addEventListener('change', (e) => {
        setDifficulty(e.target.value);
        restartGame();
        renderLeaderboard();
    });
    
    nameInput.addEventListener('input', () => {
        nameInput.value = nameInput.value.replace(/[^a-zA-Z0-9 ]/g, ''); 
        checkAssetsLoaded();
    });
    
    // Kh·ªüi t·∫°o Game
    renderLeaderboard();
    setDifficulty(difficultySelect.value); 
    restartGame(); 
    checkAssetsLoaded(); 
    requestAnimationFrame(gameLoop); 
</script>

</body>
</html>
