<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SON_MASTERPIECE_V32</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Black+Ops+One&family=Dancing+Script:wght@700&family=Noto+Sans+Symbols+2&display=swap');
        
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Share Tech Mono', monospace; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI Layer */
        #ui-layer {
            position: absolute; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 999; pointer-events: none;
        }

        .cyber-btn {
            pointer-events: auto; background: rgba(0,0,0,0.8); 
            color: #0F0; border: 2px solid #0F0;
            padding: 25px 60px; font-size: 24px; cursor: pointer; 
            font-family: 'Black Ops One', cursive; letter-spacing: 4px;
            box-shadow: 0 0 30px #0F0, inset 0 0 10px #0F0; 
            transition: 0.3s; animation: pulse 2s infinite; border-radius: 5px;
            text-shadow: 0 0 10px #0F0;
        }
        .cyber-btn:hover { background: #0F0; color: #000; box-shadow: 0 0 80px #0F0; transform: scale(1.1); }

        /* Cube */
        #cube-container { display: none; perspective: 1000px; width: 200px; height: 200px; margin-bottom: 30px;}
        #cube { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; animation: spin 5s infinite linear; }
        .face {
            position: absolute; width: 190px; height: 190px;
            border: 4px solid #0F0; background: rgba(0, 20, 0, 0.8);
            color: #0F0; font-size: 100px; display: flex;
            justify-content: center; align-items: center;
            font-family: 'Black Ops One';
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.2);
        }
        .front { transform: translateZ(100px); } .back { transform: rotateY(180deg) translateZ(100px); }
        .right { transform: rotateY(90deg) translateZ(100px); } .left { transform: rotateY(-90deg) translateZ(100px); }
        .top { transform: rotateX(90deg) translateZ(100px); } .bottom { transform: rotateX(-90deg) translateZ(100px); }
        @keyframes spin { from { transform: rotateX(0) rotateY(0); } to { transform: rotateX(360deg) rotateY(360deg); } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Message Layer */
        #msg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(40, 0, 20, 0.98) 0%, rgba(0, 0, 0, 1) 100%); 
            display: none; z-index: 3000; opacity: 0;
            flex-direction: column; justify-content: center; align-items: center;
            padding: 20px; box-sizing: border-box;
            transition: opacity 2s ease-in-out;
        }
        #msg-layer.visible { opacity: 1; }

        #msg-content {
            color: #FF69B4; font-size: clamp(16px, 4.5vw, 22px); 
            line-height: 1.8; font-family: 'Dancing Script', cursive; font-weight: bold;
            white-space: pre-wrap; width: 90%; max-width: 700px; max-height: 75vh; overflow-y: auto;
            text-shadow: 0 0 10px #FF1493; border-left: 4px solid #FF1493; padding: 20px; 
            background: rgba(20, 0, 10, 0.6); border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.2);
        }
        #skip-btn { 
            margin-top: 25px; padding: 12px 30px; border: 2px solid #FFD700; 
            background: transparent; color: #FFD700; display: none; pointer-events: auto; 
            font-weight: bold; cursor: pointer; transition: 0.3s; border-radius: 30px; font-size: 18px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        #skip-btn:hover { background: #FFD700; color: #000; box-shadow: 0 0 30px #FFD700; }

        /* Virus */
        .glitch-layer { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 2000; display:none; pointer-events:none; mix-blend-mode: overlay; }
        #virus-terminal { 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            color:#F00; font-family:'Share Tech Mono'; font-size:clamp(12px, 3vw, 16px); 
            display:none; z-index:2001; text-shadow:0 0 5px #F00; 
            background:rgba(0,0,0,0.95); padding:15px; box-sizing:border-box; overflow:hidden;
            white-space: pre-wrap; word-break: break-all;
        }

    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="glitch-div" class="glitch-layer"></div>
    <div id="virus-terminal"></div>
    
    <div id="ui-layer">
        <button id="btn-start" class="cyber-btn">KH·ªûI ƒê·ªòNG H·ªÜ TH·ªêNG</button>
        <div id="cube-container">
            <div id="cube">
                <div class="face front">10</div><div class="face back">10</div>
                <div class="face right">10</div><div class="face left">10</div>
                <div class="face top">10</div><div class="face bottom">10</div>
            </div>
        </div>
    </div>

    <div id="msg-layer">
        <div style="color: #FFD700; font-size: clamp(24px, 6vw, 36px); margin-bottom: 20px; font-family: 'Dancing Script'; text-align:center; text-shadow: 0 0 10px #FFD700;">üíå G·ª≠i D∆∞∆°ng</div>
        <div id="msg-content"></div>
        <button id="skip-btn" onclick="startFinale()">TI·∫æP T·ª§C >></button>
    </div>

    <audio id="audio" src="https://nguyenbacson.io.vn/miss-you-happy-birthday.mp3" loop></audio>

<script>
    // --- N·ªòI DUNG ---
    const LETTER = `D∆∞∆°ng ∆°i, h√¥m nay 01/03/2026, c·∫≠u tr√≤n 19 tu·ªïi.

T·ªõ ch√∫c c·∫≠u tu·ªïi m·ªõi lu√¥n xinh ƒë·∫πp r·∫°ng ng·ªùi, h·ªçc t·∫≠p th·∫≠t gi·ªèi v√† s·ªõm ƒë·∫°t ƒë∆∞·ª£c m·ªçi ∆∞·ªõc m∆°.

C·∫£m ∆°n c·∫≠u ƒë√£ ƒë·∫øn v√† l√†m cho th·∫ø gi·ªõi c·ªßa t·ªõ th√™m ƒë·∫∑c bi·ªát. Xin l·ªói v√¨ nh·ªØng l√∫c tr·∫ª con ƒë√£ l√†m c·∫≠u bu·ªìn. Mong c·∫≠u lu√¥n gi·ªØ n·ª• c∆∞·ªùi tr√™n m√¥i nh√©!

Happy Birthday, my special girl! ‚ù§Ô∏è

-- Nguy·ªÖn B·∫Øc S∆°n --`;

    const FINAL_POEM = [
        "‚ù§Ô∏è Sinh Nh·∫≠t Vui V·∫ª ‚ù§Ô∏è",
        "‚ô¶Ô∏è Th√™m tu·ªïi th√™m xinh ‚ô¶Ô∏è",
        "‚ô£Ô∏è Th√™m nhi·ªÅu s·ª©c kh·ªèe ‚ô£Ô∏è",
        "‚ô†Ô∏è V·ªõi t·ªõi ∆∞·ªõc m∆° ‚ô†Ô∏è"
    ];

    const SCRIPT = [
        { t: "G·ª¨I ƒê·∫æN\nTR∆Ø∆†NG TH·ªä D∆Ø∆†NG", c: "#0F0" },
        { t: "CH√öC M·ª™NG\nNƒÇM M·ªöI 2026", c: "#FFD700" }, 
        { t: "XU√ÇN B√çNH NG·ªå\nM√É ƒê√ÅO TH√ÄNH C√îNG", c: "#00FFFF" }, 
        { t: "HAPPY VALENTINE\n14/02 NG·ªåT NG√ÄO", c: "#FF0055" }, 
        { t: "QU·ªêC T·∫æ PH·ª§ N·ªÆ\n8/3 VUI V·∫∫", c: "#FFF" }, 
        { t: "HAPPY BIRTHDAY\nSINH NH·∫¨T TU·ªîI 19", c: "#FFD700" },
        { action: "HEART_TREND" } 
    ];

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const isMobile = window.innerWidth < 768;
    let w, h;

    // T·ªêI ∆ØU HI·ªÜU NƒÇNG & H√åNH ·∫¢NH
    // Mobile: Gap 3, Size 2.5 (V·ª´a ƒë·ªß n√©t, kh√¥ng qu√° n·∫∑ng)
    // PC: Gap 3, Size 3
    const DOT_GAP = 3; 
    const DOT_SIZE = isMobile ? 2.5 : 3; 

    let state = "IDLE"; 
    let particles = [], fireworks = [], sparkles = [], smoke = [], stars = [];
    let scriptIdx = 0;
    let countdown = 10;
    let poemIdx = 0;
    
    // ƒê√®n Beam
    let beams = [];
    let globalHue = 0;
    let beamOpacity = 1;

    // Matrix
    const M_CHARS = "01"; 
    let m_cols = [];
    let matrixColor = "#002200";

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        m_cols = Array(Math.floor(w/20)).fill(0);
        
        // T·∫°o sao n·ªÅn (Stardust)
        stars = [];
        for(let i=0; i<150; i++) {
            stars.push({
                x: Math.random()*w, y: Math.random()*h,
                size: Math.random()*1.5,
                blink: Math.random()*0.05
            });
        }

        // T·∫°o ƒë√®n Beam
        beams = [];
        let count = isMobile ? 3 : 5; // Mobile √≠t ƒë√®n h∆°n cho ƒë·ª° r·ªëi
        for(let i=0; i<count; i++) {
            beams.push({
                x: (w/(count-1)) * i,
                angle: -Math.PI/2,
                speed: 0.01 + Math.random() * 0.02,
                phase: Math.random() * Math.PI * 2
            });
        }
    }
    window.addEventListener('resize', resize);
    resize();

    // --- START ---
    document.getElementById('btn-start').onclick = function() {
        this.style.display = 'none';
        document.getElementById('audio').play().catch(()=>{});
        runCountdown();
    };

    function runCountdown() {
        state = "COUNTDOWN";
        document.getElementById('cube-container').style.display = 'block';
        const faces = document.querySelectorAll('.face');
        let tmr = setInterval(() => {
            countdown--;
            faces.forEach(f => f.innerText = countdown);
            if(countdown <= 0) {
                clearInterval(tmr);
                document.getElementById('cube-container').style.display = 'none';
                runVirus();
            }
        }, 1000);
    }

    // --- VIRUS (FULL SCREEN & FAST) ---
    function runVirus() {
        state = "VIRUS";
        const term = document.getElementById('virus-terminal');
        const glitch = document.getElementById('glitch-div');
        term.style.display = 'block'; glitch.style.display = 'block';
        matrixColor = "#400"; // N·ªÅn ƒë·ªè ƒë·∫≠m

        let logs = "";
        let count = 0;
        let t = setInterval(() => {
            // Text ng·∫´u nhi√™n hacker
            const errs = [
                "CRITICAL ERROR: KERNEL PANIC...", 
                "ACCESS DENIED... BYPASSING...", 
                "INJECTING PAYLOAD... 99%", 
                "SYSTEM OVERRIDE BY USER 'SON'",
                "WARNING: CPU OVERHEAT DETECTED",
                "DECRYPTING SECURE FILES..."
            ];
            logs += `> ${errs[Math.floor(Math.random()*errs.length)]}\n`;
            if(logs.length > 2000) logs = logs.substring(logs.length - 2000);
            
            term.innerText = logs; 
            term.scrollTop = term.scrollHeight;
            count+=1;
            
            // Rung m√†n h√¨nh
            canvas.style.transform = `translate(${Math.random()*6-3}px, ${Math.random()*6-3}px)`;

            if(count > 80) { 
                clearInterval(t);
                term.style.display = 'none'; glitch.style.display = 'none';
                canvas.style.transform = "none";
                matrixColor = "#002200"; 
                runDroneShow(); 
            }
        }, 40);
    }

    function runDroneShow() {
        state = "SHOW";
        nextScene();
    }

    function nextScene() {
        if(scriptIdx >= SCRIPT.length) return;
        let s = SCRIPT[scriptIdx++];
        
        if(s.action === "HEART_TREND") {
            runHeartTrend();
            return;
        }

        formText(s.t, s.c);
        setTimeout(nextScene, 10000); 
    }

    // --- HEART TREND (THE BEST PART) ---
    function runHeartTrend() {
        state = "HEART_TREND";
        let heartPts = getHeartOutlinePoints();
        let textPts = getTextPoints("Tr∆∞∆°ng Th·ªã\nD∆∞∆°ng", "Dancing Script");
        let allTargets = [...heartPts, ...textPts];
        
        // ƒêi·ªÅu ch·ªânh s·ªë l∆∞·ª£ng h·∫°t
        if(particles.length < allTargets.length) {
            let add = allTargets.length - particles.length;
            for(let i=0; i<add; i++) particles.push({x:w/2, y:h, tx:w/2, ty:h, c:'#FFF'});
        }

        particles.forEach((p, i) => {
            if(i < allTargets.length) {
                // Xu·∫•t ph√°t t·ª´ 2 g√≥c d∆∞·ªõi (M√®o b·∫Øn tim)
                p.x = (i % 2 === 0) ? 0 : w; 
                p.y = h;
                
                p.tx = allTargets[i].x; p.ty = allTargets[i].y;
                p.c = (i < heartPts.length) ? "#FF1493" : "#FFF"; // Tim h·ªìng, ch·ªØ tr·∫Øng
                p.vx = (Math.random()-0.5)*2; p.vy = (Math.random()-0.5)*2;
                p.isBg = false;
            } else {
                p.tx = Math.random()*w; p.ty = Math.random()*h;
                p.c = "rgba(255,105,180,0.1)"; p.isBg = true;
            }
        });

        setTimeout(runMessage, 15000);
    }

    function runMessage() {
        state = "MSG";
        const layer = document.getElementById('msg-layer');
        const content = document.getElementById('msg-content');
        const btn = document.getElementById('skip-btn');
        
        layer.style.display = 'flex';
        setTimeout(() => { layer.classList.add('visible'); }, 50);
        
        let i = 0;
        let t = setInterval(() => {
            content.innerText = LETTER.substring(0, i) + "_";
            i++;
            if(i > LETTER.length) {
                clearInterval(t);
                content.innerText = LETTER;
                btn.style.display = 'block';
                setTimeout(() => { if(state==="MSG") startFinale(); }, 30000);
            }
        }, 40);
    }

    // --- FINALE ---
    window.startFinale = function() {
        const layer = document.getElementById('msg-layer');
        layer.classList.remove('visible'); 
        state = "FINALE";
        setTimeout(() => { layer.style.display = 'none'; }, 2000);

        poemIdx = 0;
        nextPoemLine(); 

        setInterval(() => {
            if(Math.random()>0.3) launchHeartFirework();
        }, 800);
    };

    function nextPoemLine() {
        if(poemIdx < FINAL_POEM.length) {
            let textToShow = FINAL_POEM[poemIdx];
            formText(textToShow, "#FFF"); // M√†u tr·∫Øng base, v·∫Ω s·∫Ω ƒë√® RGB l√™n
            poemIdx++;
            setTimeout(nextPoemLine, 4000); 
        } else {
            setTimeout(runTheEnd, 4000);
        }
    }

    function runTheEnd() {
        state = "THE_END";
        formText("THE END", "#FFF");
        setTimeout(triggerSmokeAndLightsOut, 4000);
    }

    // --- SMOKE & ENDING ---
    function triggerSmokeAndLightsOut() {
        state = "SMOKE";
        
        // T·∫°o kh√≥i
        for(let i=0; i<60; i++) {
            smoke.push({
                x: Math.random()*w, y: h + Math.random()*100,
                vx: (Math.random()-0.5)*1.5, vy: -Math.random()*1 - 0.5,
                size: Math.random()*100 + 50,
                alpha: 0, maxAlpha: 0.3
            });
        }

        setTimeout(() => {
            state = "THANK_YOU";
            formText("THANK YOU\nFOR WATCHING", "#00FFFF");
        }, 3500);
    }

    // --- CORE DRAWING ---
    function formText(txt, color) {
        const lines = txt.split('\n');
        const tmp = document.createElement('canvas');
        const tCtx = tmp.getContext('2d');
        
        let fSize = isMobile ? 100 : 180;
        if (txt.includes("THANK YOU")) fSize = isMobile ? 60 : 120;
        let fontName = (state === "FINALE" || state === "THE_END" || state === "THANK_YOU") ? "Arial" : "Arial Black";

        tCtx.font = `900 ${fSize}px "${fontName}"`;
        let maxW = 0;
        lines.forEach(l => {
            let m = tCtx.measureText(l);
            if(m.width > maxW) maxW = m.width;
        });
        
        tmp.width = maxW + 50; tmp.height = lines.length * fSize * 1.5;
        tCtx.font = `900 ${fSize}px "${fontName}"`;
        tCtx.fillStyle = '#fff'; tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle';
        lines.forEach((l, i) => { tCtx.fillText(l, tmp.width/2, fSize + i * fSize); });
        
        getPoints(tmp, color);
    }

    function getTextPoints(txt, font) {
        const tmp = document.createElement('canvas');
        const tCtx = tmp.getContext('2d');
        let fSize = isMobile ? 40 : 60;
        tCtx.font = `bold ${fSize}px "${font}"`;
        let lines = txt.split('\n');
        let maxW = 0;
        lines.forEach(l => maxW = Math.max(maxW, tCtx.measureText(l).width));
        tmp.width = maxW + 20; tmp.height = lines.length * fSize * 1.5;
        tCtx.font = `bold ${fSize}px "${font}"`;
        tCtx.fillStyle = '#fff'; tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle';
        lines.forEach((l, i) => { tCtx.fillText(l, tmp.width/2, fSize + i*fSize); });
        
        let data = tCtx.getImageData(0,0,tmp.width,tmp.height).data;
        let pts = [];
        for(let y=0; y<tmp.height; y+=3) {
            for(let x=0; x<tmp.width; x+=3) {
                if(data[(y*tmp.width+x)*4+3] > 128) {
                    pts.push({x: w/2 - tmp.width/2 + x, y: h/2 - tmp.height/2 + y});
                }
            }
        }
        return pts;
    }

    function getHeartOutlinePoints() {
        let pts = [];
        let r = Math.min(w, h) * (isMobile ? 0.015 : 0.012);
        let count = isMobile ? 600 : 1000;
        for(let i=0; i<count; i++) {
            let t = (i/count) * Math.PI * 2;
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = -(13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t));
            pts.push({x: w/2 + x*r, y: h/2 + y*r - h*0.05});
        }
        return pts;
    }

    function getPoints(tmp, color) {
        const data = tmp.getContext('2d').getImageData(0,0, tmp.width, tmp.height).data;
        let pts = [];
        let scale = Math.min(w*0.95/tmp.width, h*0.7/tmp.height); 
        let sx = (w - tmp.width*scale)/2;
        let sy = (h - tmp.height*scale)/2;
        for(let y=0; y<tmp.height; y+=DOT_GAP) {
            for(let x=0; x<tmp.width; x+=DOT_GAP) {
                if(data[(y*tmp.width + x)*4 + 3] > 128) {
                    pts.push({x: sx + x*scale, y: sy + y*scale});
                }
            }
        }
        if(particles.length < pts.length) {
            let add = pts.length - particles.length;
            for(let i=0; i<add; i++) particles.push({x:Math.random()*w, y:Math.random()*h, tx:w/2, ty:h, c:color});
        }
        pts.sort(() => Math.random() - 0.5);

        particles.forEach((p, i) => {
            if(i < pts.length) {
                p.tx = pts[i].x; p.ty = pts[i].y; p.c = color; p.isBg = false;
            } else {
                p.tx = Math.random()*w; p.ty = Math.random()*h; p.c = "rgba(0,0,0,0)"; p.isBg = true;
            }
        });
    }

    // --- BEAMS (SMOOTH & BEAUTIFUL) ---
    function drawBeams(time) {
        // Ch·∫ø ƒë·ªô h√≤a tr·ªôn Lighter gi√∫p ƒë√®n tr√¥ng nh∆∞ √°nh s√°ng th·∫≠t
        ctx.globalCompositeOperation = 'lighter';
        
        beams.forEach((b, i) => {
            let targetAngle = Math.atan2(h/2 - h, w/2 - b.x); // H∆∞·ªõng v·ªÅ gi·ªØa
            b.angle += (targetAngle - b.angle) * 0.05;
            
            let len = h * 1.5;
            let endX = b.x + Math.cos(b.angle) * len;
            let endY = b.y + Math.sin(b.angle) * len;

            let grd = ctx.createLinearGradient(b.x, h, endX, endY);
            let hue = (globalHue + i * 40) % 360;
            // M√†u ƒë√®n nh·∫°t v√† ·∫£o di·ªáu
            grd.addColorStop(0, `hsla(${hue}, 100%, 70%, ${0.3 * beamOpacity})`); 
            grd.addColorStop(1, "rgba(0,0,0,0)");

            if(beamOpacity > 0.01) {
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.moveTo(b.x - 20, h);
                ctx.lineTo(endX - w*0.1, endY);
                ctx.lineTo(endX + w*0.1, endY);
                ctx.lineTo(b.x + 20, h);
                ctx.closePath();
                ctx.fill();
            }
        });
        ctx.globalCompositeOperation = 'source-over';
    }

    function drawSmoke() {
        smoke.forEach(s => {
            s.y += s.vy; s.x += s.vx;
            if(s.alpha < s.maxAlpha) s.alpha += 0.005;
            let grd = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size);
            grd.addColorStop(0, `rgba(120, 120, 120, ${s.alpha})`);
            grd.addColorStop(1, `rgba(0, 0, 0, 0)`);
            ctx.fillStyle = grd;
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
        });
    }

      // --- EFFECTS ---
    function launchHeartFirework() {
        let x = Math.random() * w; let y = h;
        let ty = h*0.2 + Math.random()*h*0.3;
        fireworks.push({x:x, y:y, tx:x, ty:ty, vy:-12, c:`hsl(${Math.random()*60+330},100%,60%)`});
    }

    function explode(fw) {
        for(let i=0; i<30; i++) {
            let t = (i/30) * Math.PI * 2;
            let dx = 16 * Math.pow(Math.sin(t), 3);
            let dy = -(13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t));
            let s = Math.random() * 0.1 + 0.05; 
            sparkles.push({x:fw.x, y:fw.y, vx:dx*s, vy:dy*s, c:fw.c, l:1.5, g:0.05});
        }
    }

    // --- LOOP ---
    let time = 0;
    function loop() {
        requestAnimationFrame(loop);
        time++;
        globalHue += 0.5;

        // Fade Out Beams Logic
        if(state === "SMOKE" || state === "THANK_YOU") {
            if(beamOpacity > 0) beamOpacity -= 0.01;
        }

        // Background Clear
        ctx.fillStyle = "rgba(0,0,0,0.2)"; 
        if(state === "HEART_TREND") ctx.fillStyle = "rgba(20,0,20,0.2)";
        if(state === "VIRUS") ctx.fillStyle = "rgba(50,0,0,0.2)";
        ctx.fillRect(0,0,w,h);
        
        // Draw Stars (Stardust)
        if(state !== "VIRUS" && state !== "MSG") {
            ctx.fillStyle = "#FFF";
            stars.forEach(s => {
                if(Math.random() > 0.9 + s.blink) 
                    ctx.fillRect(s.x, s.y, s.size, s.size);
            });
        }

        // Matrix
        if(state !== "MSG") {
            ctx.font = "14px monospace";
            m_cols.forEach((y, i) => {
                ctx.fillStyle = matrixColor;
                let char = M_CHARS[Math.floor(Math.random()*2)];
                ctx.fillText(char, i*20, y);
                m_cols[i] = (y > h + Math.random()*10000) ? 0 : y + 20;
            });
        }

        // Beams
        if((state === "SHOW" || state === "HEART_TREND" || state === "FINALE" || state === "THE_END" || state === "SMOKE") && state !== "MSG") {
            drawBeams(time);
        }

        // Smoke
        if(state === "SMOKE" || state === "THANK_YOU") {
            drawSmoke();
        }

        // Particles
        let beat = (state === "HEART_TREND") ? 1 + Math.sin(time*0.1)*0.03 : 1;
        
        particles.forEach(p => {
            let dx = p.tx - p.x;
            let dy = p.ty - p.y;
            
            if(state === "HEART_TREND") {
                if(!p.isBg) {
                    p.x += dx * 0.05; p.y += dy * 0.05; 
                    let cx = w/2; let cy = h/2;
                    let fx = cx + (p.x-cx)*beat;
                    let fy = cy + (p.y-cy)*beat;
                    
                    // Mode Lighter cho tim s√°ng r·ª±c
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = p.c; 
                    ctx.fillRect(fx, fy, DOT_SIZE, DOT_SIZE);
                    ctx.globalCompositeOperation = 'source-over';
                } else {
                    p.y -= 1; if(p.y < 0) p.y = h;
                    ctx.fillStyle = p.c; ctx.fillRect(p.x, p.y, 2, 2);
                }
            } else {
                p.x += dx * 0.1; p.y += dy * 0.1;
                
                // RGB Flow cho Finale
                if((state === "FINALE" || state === "THE_END" || state === "THANK_YOU") && !p.isBg) {
                    let hue = (p.x / w * 120 + time * 0.2) % 360; 
                    
                    // TƒÉng ƒë·ªô s√°ng (Lightness) l√™n 70% ƒë·ªÉ ch·ªØ r√µ
                    ctx.fillStyle = `hsl(${hue}, 100%, 70%)`;
                    
                    // V·∫Ω Glow nh·∫π
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = ctx.fillStyle;
                } else {
                    ctx.fillStyle = p.c;
                    ctx.shadowBlur = 0;
                }
                
                ctx.fillRect(p.x, p.y, DOT_SIZE, DOT_SIZE);
                ctx.shadowBlur = 0; // Reset
            }
        });

        // Fireworks
        for(let i=fireworks.length-1; i>=0; i--) {
            let f = fireworks[i]; f.y += f.vy; f.vy += 0.2;
            ctx.fillStyle = f.c; ctx.fillRect(f.x, f.y, 3, 3);
            if(f.vy >= 0) { explode(f); fireworks.splice(i, 1); }
        }
        for(let i=sparkles.length-1; i>=0; i--) {
            let s = sparkles[i]; s.x += s.vx; s.y += s.vy; s.vy += s.g; s.l -= 0.03;
            if(s.l <= 0) sparkles.splice(i, 1);
            else { ctx.globalAlpha = Math.min(s.l, 1); ctx.fillStyle = s.c; ctx.fillRect(s.x, s.y, 2, 2); ctx.globalAlpha=1; }
        }
    }
    loop();

</script>
</body>
</html>