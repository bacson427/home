<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HPBD & HPNY (V20 Auto Show)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@900&family=Montserrat:wght@800&family=Dancing+Script:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Cinzel', serif;
            touch-action: none;
        }

        .galaxy-bg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            z-index: 0;
        }

        .stars {
            width: 1px; height: 1px;
            background: transparent;
            animation: animStar 100s linear infinite;
        }

        @keyframes animStar { from { transform: translateY(0px); } to { transform: translateY(-2000px); } }

        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        #ui-layer {
            position: absolute; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; pointer-events: none; z-index: 100;
        }

        .btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.05);
            color: #d4af37; border: 1px solid rgba(212, 175, 55, 0.5);
            padding: 15px 40px; font-size: 18px;
            cursor: wait; transition: all 0.5s;
            text-transform: uppercase; letter-spacing: 4px;
            font-family: 'Cinzel', serif; font-weight: 900;
            margin-top: 30px; border-radius: 30px; 
            backdrop-filter: blur(4px);
            opacity: 0.5;
        }

        .btn.ready { 
            cursor: pointer; opacity: 1; 
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            animation: pulse 3s infinite;
        }
        .btn.ready:hover { background: rgba(255, 215, 0, 0.2); transform: scale(1.05); color: #fff; }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.4); } 50% { box-shadow: 0 0 0 15px rgba(212, 175, 55, 0); } 100% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0); } }

        .hint { font-family: 'Montserrat', sans-serif; font-size: 11px; color: rgba(255, 255, 255, 0.4); margin-top: 20px; letter-spacing: 2px; text-transform: uppercase; }
        #loading-text { margin-top: 15px; font-size: 12px; color: #d4af37; font-family: 'Montserrat', sans-serif; }

        /* M√†n t√¢m t∆∞ */
        #letter-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #8B0000;
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
            font-family: 'Arial', sans-serif;
            padding: 20px;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 2s ease-in-out;
        }

        #letter-content {
            max-width: 90%;
            max-height: 80vh;
            text-align: center;
            font-size: clamp(16px, 3.5vw, 22px);
            line-height: 1.6;
            overflow-y: auto;
            padding: 15px;
            opacity: 1;
        }

        .typing-cursor {
            display: inline-block;
            width: 2px;
            height: 1em;
            background-color: white;
            animation: blink 1s infinite;
            vertical-align: middle;
            margin-left: 2px;
        }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        #letter-signature {
            margin-top: 30px;
            font-size: clamp(18px, 4vw, 22px);
            font-family: 'Dancing Script', cursive;
            opacity: 0;
            transition: opacity 1.5s;
            text-align: center;
            padding: 0 20px;
        }

        .fade-out { animation: fadeOut 5s ease-in-out forwards; }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
    </style>
</head>
<body>

    <div class="galaxy-bg">
        <div id="stars" class="stars"></div>
    </div>
    <canvas id="mainCanvas"></canvas>

    <div id="ui-layer">
        <button id="start-btn" class="btn">LOADING...</button>
        <div id="loading-text">LOADING...</div>
        <div id="hint-text" class="hint" style="display:none">S·∫µn s√†ng khai ti·ªác ph√°o hoa...</div>
        <button id="next-phase-btn" class="btn ready" style="display:none">LET'S GO</button>
    </div>

    <div id="letter-container">
        <div id="letter-content"></div>
        <div id="letter-signature"></div>
    </div>

    <audio id="bg-music" src="https://nguyenbacson.io.vn/miss-you-happy-birthday.mp3" loop></audio>

    <script>
        const CONFIG = {
            NAME: "Tr∆∞∆°ng Th·ªã D∆∞∆°ng",
            BIRTHDAY: "01/03/2007",
            COLORS: {
                GOLD: { h: 48, s: 100, l: 60 },
                RED: { h: 350, s: 100, l: 60 },
                CYAN: { h: 190, s: 100, l: 70 },
                WHITE: { h: 0, s: 0, l: 100 },
                PINK: { h: 320, s: 100, l: 70 }
            }
        };

        const isMobile = window.innerWidth < 768;
        const PARTICLE_SIZE = isMobile ? 3 : 2.5;
        const SCAN_STEP = isMobile ? 12 : 10;

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const music = document.getElementById('bg-music');
        let width, height;

        const letterContainer = document.getElementById('letter-container');
        const letterContent = document.getElementById('letter-content');
        const letterSignature = document.getElementById('letter-signature');
        let letterText = "D∆∞∆°ng ∆°i, h√¥m nay l√† ng√†y 01/03/2026, c·∫≠u c≈©ng tr√≤n 19 tu·ªïi. T·ªõ ch√∫c c·∫≠u ng√†y c√†ng xinh ƒë·∫πp, h·ªçc gi·ªèi, ƒë·∫°t ƒë∆∞·ª£c k·∫øt qu·∫£ cao trong h·ªçc t·∫≠p, s·ªõm ƒë·∫°t ƒë∆∞·ª£c nh·ªØng ∆∞·ªõc m∆° m√† c·∫≠u ƒë√£ t·ª´ng mong ∆∞·ªõc. T·ªõ c≈©ng xin l·ªói, th·ªùi gian v·ª´a qua ƒë√£ l√†m c·∫≠u ph·∫£i bu·ªìn, gi·∫≠n, ch√°n gh√©t t·ªõ. Th√¥i c≈©ng ƒë√£ qua nƒÉm m·ªõi t·ªõ mong r·∫±ng c·∫≠u c√≥ th·ªÉ kh√¥ng ƒë·ªÉ b·ª•ng ƒë·∫øn t√≠nh c√°ch \"tr·∫ª tr√¢u\" c·ªßa t·ªõ. T·ªõ c·∫£m ∆°n c·∫≠u!";
        let letterIndex = 0;
        let typingSpeed = 60;
        let isTyping = false;
        let typingInterval;

        function resize() { 
            width = canvas.width = window.innerWidth; 
            height = canvas.height = window.innerHeight; 
        }
        window.addEventListener('resize', resize); 
        resize();

        document.fonts.ready.then(() => {
            const btn = document.getElementById('start-btn');
            btn.innerText = "KHAI TI·ªÜC"; 
            btn.classList.add('ready');
            document.getElementById('loading-text').style.display = 'none';
            document.getElementById('hint-text').style.display = 'block';
            btn.onclick = triggerAction;
        });

        let state = "IDLE"; 
        let fireworks = [], particles = [], drones = [];
        let globalHue = 0;
        let isFinale = false;
        let countdownVal = 10;
        let transitionAlpha = 0;
        let shockwaves = [];
        let countdownTimer = null;
        let audioContext, analyser, dataArray, bufferLength;
        let fireworksSizeMultiplier = 1;
        let currentDisplayingMessage = null;
        let messageHoldTime = 0;
        let messageStartTime = 0;
        let currentShapePoints = [];

        const startBtn = document.getElementById('start-btn'), 
              nextBtn = document.getElementById('next-phase-btn'), 
              hintText = document.getElementById('hint-text');

        function initAudioAnalysis() {
            if (!music.src) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(music);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            } catch(e) {
                console.log("Audio analysis kh√¥ng kh·∫£ d·ª•ng");
            }
        }

        function getAudioVolume() {
            if (!analyser) return 0.5;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            return sum / (bufferLength * 256);
        }
function triggerAction() {
            if (state === "IDLE") {
                state = "FIREWORKS";
                startBtn.style.display = hintText.style.display = 'none';
                music.play().then(() => {
                    initAudioAnalysis();
                }).catch(e => console.log("Audio play blocked"));

                launchFireworksPeriod(8000, () => { 
                    state = "WAITING_1"; 
                    nextBtn.style.display = hintText.style.display = 'block'; 
                    hintText.innerText = "B·∫•m ƒë·ªÉ b·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c";
                });
            } else if (state === "WAITING_1") {
                state = "COUNTDOWN";
                nextBtn.style.display = hintText.style.display = 'none';
                countdownVal = 10;
                resetCinematicNumber(); 

                countdownTimer = setInterval(() => {
                    countdownVal--;
                    if (countdownVal > 0) { 
                        resetCinematicNumber();
                        if(countdownVal % 2 === 0) createShapedFirework('STAR');
                    } 
                    else { 
                        clearInterval(countdownTimer); 
                        startTransitionSequence();
                    }
                }, 1000);
            }
        }

        function startTransitionSequence() {
            state = "TRANSITION";
            let barrage = setInterval(() => {
                createFirework(Math.random()*width, height*0.5);
            }, 300);

            setTimeout(() => {
                clearInterval(barrage);
                state = "DRONE";
                startDroneSequence();
            }, 5000);
        }

        function renderTransitionText() {
            if(transitionAlpha < 1) transitionAlpha += 0.01;
            ctx.save();
            ctx.translate(width/2, height/2);
            let dynamicFontSize = Math.min(width * 0.09, 65);
            ctx.globalAlpha = transitionAlpha;
            ctx.font = `900 ${dynamicFontSize}px "Cinzel"`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#FFD700';
            ctx.fillText("WELCOME D∆Ø∆†NG", 0, 0);
            ctx.restore();
        }

        function resetCinematicNumber() {
            shockwaves.push({ r: 0, alpha: 1, speed: 5 });
        }

        function renderCinematicCountdown() {
            const cx = width / 2, cy = height / 2;
            for(let i = shockwaves.length - 1; i >= 0; i--) {
                let sw = shockwaves[i]; 
                sw.r += sw.speed; 
                sw.alpha -= 0.015;
                if(sw.alpha <= 0) {
                    shockwaves.splice(i, 1);
                } else {
                    ctx.beginPath(); 
                    ctx.arc(cx, cy, sw.r, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${sw.alpha})`; 
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            if(countdownVal > 0) {
                ctx.save(); 
                ctx.translate(cx, cy);
                ctx.font = '900 90px "Cinzel"'; 
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#ffd700'; 
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';
                ctx.fillText(countdownVal, 0, 0);
                ctx.restore();
            }
        }

        function launchFireworksPeriod(duration, callback) {
            let start = Date.now();
            let interval = setInterval(() => {
                if(Date.now() - start > duration) { 
                    clearInterval(interval); 
                    if(callback) callback(); 
                }
                createFirework();
            }, 500);
        }

        function createFirework(x, y, shape = 'NORMAL') {
            let colors = ['#FFD700', '#FF0055', '#00FFFF', '#FFFFFF', '#FF6B9D'];
            fireworks.push({ 
                x: x || Math.random() * width, 
                y: height, 
                ty: y || height * 0.2 + Math.random() * (height * 0.3), 
                color: colors[Math.floor(Math.random() * colors.length)], 
                exploded: false, 
                speed: 3 + Math.random() * 2,
                shape: shape,
                size: 2
            });
        }

        function createShapedFirework(shapeType) {
            createFirework(width/2 + (Math.random()-0.5)*width*0.5, height*0.3, shapeType);
        }

        function explodeFirework(fw) {
            fw.exploded = true;
            let count = 25 + Math.floor(getAudioVolume() * 25);
            let baseSize = 1.2 + fireworksSizeMultiplier * 1.8;
            
            for(let i=0; i<count; i++) {
                let angle = (i/count) * Math.PI * 2;
                let speed = Math.random() * 1.2 + 0.5 + getAudioVolume() * 1.2;
                particles.push({ 
                    x: fw.x, 
                    y: fw.y, 
                    vx: Math.cos(angle) * speed, 
                    vy: Math.sin(angle) * speed, 
                    color: fw.color, 
                    life: 1, 
                    decay: 0.012 + Math.random() * 0.008,
                    gravity: 0.025,
                    size: baseSize
                });
            }
        }

        function startDroneSequence() {
            const sequence = [
                { t: 1000, txt: "üéâCH√öC M·ª™NGüéä", color: CONFIG.COLORS.RED, mode: 'shift', holdTime: 7000 },
                { t: 9000, txt: "üåüNƒÇM M·ªöI 2026üåü", color: CONFIG.COLORS.GOLD, mode: 'shift', holdTime: 7000 },
                { t: 17000, txt: "üê¥B√çNH NG·ªåüê¥", color: CONFIG.COLORS.CYAN, mode: 'static', holdTime: 7000 },
                { t: 25000, txt: "üíùHAPPY VALENTINEüíù", color: CONFIG.COLORS.PINK, mode: 'shift', holdTime: 7000 },
                { t: 33000, txt: "üíêQU·ªêC T·∫æ PH·ª§ N·ªÆ 8/3üíê", color: CONFIG.COLORS.RED, mode: 'rainbow', holdTime: 7000 },
                { t: 41000, txt: "üçÄCH√öC M·ª™NG SINH NH·∫¨T TU·ªîI 19üçÄ", color: CONFIG.COLORS.GOLD, mode: 'shift', holdTime: 8000 },
                { t: 50000, txt: CONFIG.NAME, color: CONFIG.COLORS.PINK, font: 'Dancing Script', mode: 'rainbow', holdTime: 7000 },
                { t: 58000, txt: "‚ù§Ô∏è SINH NH·∫¨T VUI V·∫∫ NH√â D∆Ø∆†NG üíï", color: CONFIG.COLORS.GOLD, mode: 'rainbow', holdTime: 8000 },
                { t: 67000, action: "finalShow" },
                { t: 82000, action: "startLetter" }
            ];

            sequence.forEach(s => {
                setTimeout(() => {
                    if(s.txt) {
                        currentDisplayingMessage = s.txt;
                        messageHoldTime = s.holdTime;
                        messageStartTime = Date.now();
                        formText(s.txt, s.color, s.font || 'Cinzel', s.mode);
                    }
                    if(s.action === "finalShow") startFinalShow();
                    if(s.action === "startLetter") startLetterSequence();
                }, s.t);
            });
        }

        function startFinalShow() {
            isFinale = true;
            currentDisplayingMessage = "FINAL_SHOW";
            
            // T·∫°o b√°nh sinh nh·∫≠t v√† tr√°i tim c√πng l√∫c
            setTimeout(() => {
                formShape('HEART', CONFIG.COLORS.RED, 'rainbow');
                setTimeout(() => {
                    formShape('CAKE', CONFIG.COLORS.GOLD, 'shift');
                }, 300);
            }, 800);

            // B·∫Øn ph√°o hoa ƒë·∫∑c bi·ªát trong 15 gi√¢y
            let specialFireworks = setInterval(() => {
                let shapes = ['HEART', 'STAR', 'CIRCLE'];
                createFirework(Math.random()*width, height*0.3, shapes[Math.floor(Math.random()*shapes.length)]);
            }, 1200);

            setTimeout(() => {
                clearInterval(specialFireworks);
            }, 15000);
        }

        function startLetterSequence() {
            state = "LETTER";
            drones = []; 
            fireworks = []; 
            particles = [];
            letterContainer.style.display = 'flex';
            setTimeout(() => {
                letterContainer.style.opacity = '1';
                setTimeout(startTyping, 1500);
            }, 200);
        }
function startTyping() {
            isTyping = true;
            letterIndex = 0;
            letterContent.innerHTML = '';
            typingInterval = setInterval(() => {
                if (letterIndex < letterText.length) {
                    letterContent.innerHTML = letterText.substring(0, letterIndex + 1) + '<span class="typing-cursor"></span>';
                    letterIndex++;
                } else {
                    clearInterval(typingInterval);
                    letterContent.innerHTML = letterText;
                    setTimeout(() => {
                        letterSignature.innerHTML = "Ng∆∞·ªùi g·ª≠i: NGUY·ªÑN B·∫ÆC S∆†N<br>Ng∆∞·ªùi nh·∫≠n: TR∆Ø∆†NG TH·ªä D∆Ø∆†NG";
                        letterSignature.style.opacity = '1';
                    }, 1500);
                }
            }, typingSpeed);
        }

        function formText(text, hslColor, fontName, mode) {
            const offCv = document.createElement('canvas');
            const offCtx = offCv.getContext('2d');
            
            // T√≠nh to√°n font size ƒë·ªông ƒë·ªÉ ph√π h·ª£p v·ªõi m√†n h√¨nh
            let maxWidth = width * 0.85;
            let fontSize = isMobile ? 40 : 65;
            
            // Ki·ªÉm tra v√† ƒëi·ªÅu ch·ªânh font size cho ph√π h·ª£p
            offCtx.font = `900 ${fontSize}px "${fontName}"`;
            let textWidth = offCtx.measureText(text).width;
            
            // Gi·∫£m font size n·∫øu text qu√° d√†i
            while (textWidth > maxWidth && fontSize > 20) {
                fontSize -= 2;
                offCtx.font = `900 ${fontSize}px "${fontName}"`;
                textWidth = offCtx.measureText(text).width;
            }
            
            // TƒÉng font size n·∫øu text qu√° ng·∫Øn (tr√™n desktop)
            if (!isMobile && textWidth < maxWidth * 0.5 && fontSize < 80) {
                fontSize = Math.min(80, Math.floor(maxWidth / textWidth * fontSize * 0.9));
                offCtx.font = `900 ${fontSize}px "${fontName}"`;
                textWidth = offCtx.measureText(text).width;
            }
            
            offCv.width = Math.min(textWidth + 40, maxWidth);
            offCv.height = fontSize * 1.6;
            
            // Clear canvas
            offCtx.clearRect(0, 0, offCv.width, offCv.height);
            offCtx.font = `900 ${fontSize}px "${fontName}"`;
            offCtx.textAlign = 'center'; 
            offCtx.textBaseline = 'middle';
            offCtx.fillStyle = '#fff';
            offCtx.fillText(text, offCv.width/2, offCv.height/2);

            const scale = Math.min(width * 0.9 / offCv.width, height * 0.55 / offCv.height, 1);
            const data = offCtx.getImageData(0,0, offCv.width, offCv.height).data;
            let points = [];
            
            // S·ª≠ d·ª•ng b∆∞·ªõc nh·∫£y l·ªõn h∆°n ƒë·ªÉ t·ªëi ∆∞u
            const step = Math.max(SCAN_STEP, Math.ceil(offCv.width / 100));
            
            for(let y=0; y<offCv.height; y+=step) {
                for(let x=0; x<offCv.width; x+=step) {
                    if(data[(y*offCv.width + x)*4 + 3] > 128) {
                        points.push({ 
                            x: (width - offCv.width * scale)/2 + x * scale, 
                            y: (height - offCv.height * scale)/2 + y * scale 
                        });
                    }
                }
            }
            
            // Gi·ªõi h·∫°n s·ªë ƒëi·ªÉm ƒë·ªÉ tƒÉng hi·ªáu su·∫•t
            if (points.length > 400) {
                let sampledPoints = [];
                let skip = Math.ceil(points.length / 400);
                for (let i = 0; i < points.length; i += skip) {
                    sampledPoints.push(points[i]);
                }
                points = sampledPoints;
            }
            
            currentShapePoints = points;
            updateDrones(points, hslColor, mode);
        }

        function formShape(type, hslColor, mode) {
            let points = [], cx = width/2, cy = height/2;
            let size = Math.min(width, height) * 0.32;
            let count = isMobile ? 200 : 400;
            
            if (type === 'HEART') {
                for (let i = 0; i < count; i++) {
                    let t = (i / count) * Math.PI * 2;
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                    points.push({ 
                        x: cx + x * (size/28), 
                        y: cy + y * (size/28) 
                    });
                }
            } else if (type === 'CAKE') {
                // T·∫°o h√¨nh b√°nh sinh nh·∫≠t
                const layers = 3;
                const candles = 19;
                
                // C√°c l·ªõp b√°nh
                for (let layer = 0; layer < layers; layer++) {
                    const layerRadius = size * (0.65 - layer * 0.12);
                    const layerY = cy + size * 0.25 - layer * (size * 0.12);
                    const layerPoints = 80;
                    
                    for (let i = 0; i < layerPoints; i++) {
                        let angle = (i / layerPoints) * Math.PI * 2;
                        points.push({
                            x: cx + Math.cos(angle) * layerRadius,
                            y: layerY + Math.sin(angle) * (layerRadius * 0.25)
                        });
                    }
                }
                
                // N·∫øn
                for (let i = 0; i < candles; i++) {
                    let angle = (i / candles) * Math.PI * 2;
                    let candleX = cx + Math.cos(angle) * (size * 0.45);
                    let candleY = cy - size * 0.08;
                    
                    // Th√¢n n·∫øn
                    for (let j = 0; j < 3; j++) {
                        points.push({
                            x: candleX,
                            y: candleY + j * 2
                        });
                    }
                    
                    // L·ª≠a n·∫øn
                    points.push({
                        x: candleX,
                        y: candleY - 3
                    });
                }
            } else if (type === 'STAR') {
                const spikes = 5;
                const outerRadius = size * 0.35;
                const innerRadius = outerRadius * 0.5;
                
                for (let i = 0; i < count; i++) {
                    let angle = (i / count) * Math.PI * 2;
                    let radius = i % 2 === 0 ? outerRadius : innerRadius;
                    points.push({
                        x: cx + Math.cos(angle) * radius,
                        y: cy + Math.sin(angle) * radius
                    });
                }
            } else if (type === 'CIRCLE') {
                for (let i = 0; i < count; i++) {
                    let angle = (i / count) * Math.PI * 2;
                    points.push({
                        x: cx + Math.cos(angle) * size * 0.35,
                        y: cy + Math.sin(angle) * size * 0.35
                    });
                }
            }
            
            currentShapePoints = points;
            updateDrones(points, hslColor, mode);
        }

        function updateDrones(points, hslColor, mode) {
            // Gi·ªØ nguy√™n drone hi·ªán t·∫°i, ch·ªâ thay ƒë·ªïi m·ª•c ti√™u
            if (drones.length === 0) {
                // Kh·ªüi t·∫°o drones t·ª´ c√°c v·ªã tr√≠ ng·∫´u nhi√™n tr√™n m√†n h√¨nh
                for (let i = 0; i < points.length; i++) {
                    drones.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        tx: points[i].x,
                        ty: points[i].y,
                        baseHsl: hslColor,
                        colorMode: mode,
                        size: PARTICLE_SIZE,
                        speed: 0.01 + Math.random() * 0.01,
                        arrived: false
                    });
                }
            } else {
                // C·∫≠p nh·∫≠t m·ª•c ti√™u cho drones hi·ªán c√≥
                for (let i = 0; i < Math.min(drones.length, points.length); i++) {
                    drones[i].tx = points[i].x;
                    drones[i].ty = points[i].y;
                    drones[i].baseHsl = hslColor;
                    drones[i].colorMode = mode;
                    drones[i].arrived = false;
                }
                
                // Th√™m drones m·ªõi n·∫øu c·∫ßn
                for (let i = drones.length; i < points.length; i++) {
                    drones.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        tx: points[i].x,
                        ty: points[i].y,
                        baseHsl: hslColor,
                        colorMode: mode,
                        size: PARTICLE_SIZE,
                        speed: 0.01 + Math.random() * 0.01,
                        arrived: false
                    });
                }
                
                // Lo·∫°i b·ªè drones th·ª´a
                if (drones.length > points.length) {
                    // Thay v√¨ x√≥a ngay, h√£y di chuy·ªÉn ch√∫ng ra kh·ªèi m√†n h√¨nh
                    for (let i = points.length; i < drones.length; i++) {
                        drones[i].tx = -100;
                        drones[i].ty = -100;
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (state === "LETTER") return;
            
            ctx.clearRect(0, 0, width, height); 
            globalHue += 0.2;

            // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc ph√°o hoa theo √¢m nh·∫°c
            if (analyser) {
                fireworksSizeMultiplier = 0.7 + getAudioVolume() * 1.8;
            }

            if (state === "COUNTDOWN") renderCinematicCountdown();
            if (state === "TRANSITION") renderTransitionText();

            ctx.globalCompositeOperation = 'lighter';
            
            // C·∫≠p nh·∫≠t v√† v·∫Ω ph√°o hoa
            for(let i = fireworks.length - 1; i >= 0; i--) {
                let fw = fireworks[i];
                if (!fw.exploded) {
                    fw.y -= fw.speed;
                    fw.size = 1.8 * fireworksSizeMultiplier;
                    
                    ctx.fillStyle = fw.color; 
                    ctx.beginPath(); 
                    ctx.arc(fw.x, fw.y, fw.size, 0, Math.PI*2); 
                    ctx.fill();
                    
                    if (fw.y <= fw.ty) {
                        explodeFirework(fw);
                        fireworks.splice(i, 1);
                    }
                }
            }
            
            // C·∫≠p nh·∫≠t v√† v·∫Ω h·∫°t ph√°o hoa
            for(let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx; 
                p.y += p.vy; 
                p.vy += p.gravity; 
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else { 
                    ctx.fillStyle = p.color; 
                    ctx.globalAlpha = p.life * 0.8; 
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            if (state === "DRONE" || isFinale) {
                let allArrived = drones.length > 0;
                let activeDrones = 0;
                
                drones.forEach(d => {
                    // Ki·ªÉm tra xem drone c√≥ ·ªü trong m√†n h√¨nh kh√¥ng
                    if (d.tx < -50 || d.ty < -50) {
                        // Di chuy·ªÉn drone ra kh·ªèi m√†n h√¨nh
                        const dx = d.tx - d.x;
                        const dy = d.ty - d.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // X√≥a drone ƒë√£ ra kh·ªèi m√†n h√¨nh
                            return;
                        }
                        
                        d.x += dx * 0.05;
                        d.y += dy * 0.05;
                        return;
                    }
                    
                    activeDrones++;
                    
                    // T√≠nh kho·∫£ng c√°ch ƒë·∫øn m·ª•c ti√™u
                    const dx = d.tx - d.x;
                    const dy = d.ty - d.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Ki·ªÉm tra xem drone ƒë√£ ƒë·∫øn ƒë√≠ch ch∆∞a
                    if (distance < 2) {
                        d.x = d.tx;
                        d.y = d.ty;
                        d.arrived = true;
                    } else {
                        allArrived = false;
                        // Di chuy·ªÉn drone ƒë·∫øn m·ª•c ti√™u
                        d.x += dx * d.speed;
                        d.y += dy * d.speed;
                    }
                    
                    // T√≠nh m√†u s·∫Øc
                    let h = d.baseHsl?.h || 0;
                    if (d.colorMode === 'rainbow') {
                        h = (h + globalHue * 0.3) % 360;
                    } else if (d.colorMode === 'shift') {
                        h = (d.baseHsl.h + globalHue * 0.2) % 360;
                    }
                    
                    // ƒê·ªô trong su·ªët
                    const alpha = d.arrived ? 0.95 : 0.7;
                    
                    // V·∫Ω drone
                    ctx.fillStyle = `hsla(${h}, ${d.baseHsl?.s || 100}%, ${d.baseHsl?.l || 60}%, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Ki·ªÉm tra th·ªùi gian gi·ªØ cho m·ªói th√¥ng ƒëi·ªáp
                if (currentDisplayingMessage && messageStartTime > 0) {
                    const elapsedTime = Date.now() - messageStartTime;
                    const shouldHold = elapsedTime < messageHoldTime;
                    
                    // N·∫øu ƒë√£ ƒë·∫øn l√∫c chuy·ªÉn th√¥ng ƒëi·ªáp ti·∫øp theo, t·ª´ t·ª´ x√≥a drones
                    if (!shouldHold && drones.length > 0) {
                        // Di chuy·ªÉn drones ra kh·ªèi m√†n h√¨nh
                        drones.forEach(d => {
                            d.tx = -100 - Math.random() * 100;
                            d.ty = -100 - Math.random() * 100;
                        });
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';
        }

        // T·∫°o sao n·ªÅn tƒ©nh
        const starBox = document.getElementById('stars');
        let starsCss = '';
        for(let i=0; i<100; i++) {
            starsCss += `${Math.random()*2000}px ${Math.random()*2000}px #FFF, `;
        }
        starBox.style.boxShadow = starsCss.slice(0, -2);

        nextBtn.onclick = triggerAction;
        animate();
    </script>
</body>
</html>